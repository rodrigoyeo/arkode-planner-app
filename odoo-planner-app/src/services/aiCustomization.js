// AI Task Customization Service
// Generates context-specific tasks using Claude or OpenAI API based on questionnaire responses

const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';
const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';

/**
 * Detect which AI provider to use based on available API keys
 * @returns {Object} { provider: 'claude'|'openai'|null, key: string|null }
 */
function detectProvider() {
  const claudeKey = import.meta.env.VITE_CLAUDE_API_KEY;
  const openaiKey = import.meta.env.VITE_OPENAI_API_KEY;

  if (claudeKey) {
    return { provider: 'claude', key: claudeKey };
  }
  if (openaiKey) {
    return { provider: 'openai', key: openaiKey };
  }
  return { provider: null, key: null };
}

/**
 * Generate AI-customized tasks for a specific phase
 * @param {Object} responses - All questionnaire responses
 * @param {string} phase - 'clarity', 'implementation', or 'adoption'
 * @returns {Promise<Array>} Array of AI-generated tasks
 */
export async function generateCustomTasks(responses, phase) {
  const { provider, key } = detectProvider();

  if (!provider) {
    console.warn('No AI API key provided (Claude or OpenAI). Skipping AI customization.');
    return [];
  }

  console.log(`Using ${provider.toUpperCase()} for AI task generation`);

  try {
    const context = buildContext(responses);
    const prompt = buildPrompt(context, phase, responses.language || 'English');

    // Show user how AI uses questionnaire data
    console.log(`\nüìã AI PROMPT FOR ${phase.toUpperCase()} PHASE:`);
    console.log('‚îÅ'.repeat(80));
    console.log(prompt);
    console.log('‚îÅ'.repeat(80));
    console.log('üëÜ This prompt shows how your questionnaire answers are used by AI\n');

    let tasks;
    if (provider === 'claude') {
      tasks = await generateWithClaude(key, prompt);
    } else if (provider === 'openai') {
      tasks = await generateWithOpenAI(key, prompt);
    }

    if (!tasks || tasks.length === 0) {
      console.warn(`No tasks generated by ${provider}`);
      return [];
    }

    console.log(`‚úÖ Successfully parsed ${tasks.length} tasks from ${provider}`);

    // Add metadata to tasks
    return tasks.map(task => ({
      ...task,
      task_type: 'ai_generated',
      phase: phase.charAt(0).toUpperCase() + phase.slice(1),
      tags: Array.isArray(task.tags) ? task.tags : [task.tags || phase],
      ai_provider: provider
    }));

  } catch (error) {
    console.error('Error generating AI tasks:', error);
    return [];
  }
}

/**
 * Generate tasks using Claude API
 */
async function generateWithClaude(apiKey, prompt) {
  const response = await fetch(CLAUDE_API_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01'
    },
    body: JSON.stringify({
      model: 'claude-3-5-sonnet-20241022',
      max_tokens: 2000,
      messages: [{
        role: 'user',
        content: prompt
      }]
    })
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('Claude API error:', response.status, errorText);
    return [];
  }

  const data = await response.json();
  const tasksText = data.content[0].text;

  console.log('\nüîç RAW CLAUDE RESPONSE:');
  console.log('‚îÅ'.repeat(80));
  console.log(tasksText);
  console.log('‚îÅ'.repeat(80));

  return extractTasksFromJSON(tasksText);
}

/**
 * Generate tasks using OpenAI API
 */
async function generateWithOpenAI(apiKey, prompt) {
  const response = await fetch(OPENAI_API_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      model: 'gpt-4-turbo-preview',
      messages: [{
        role: 'system',
        content: 'You are an expert Odoo implementation consultant. Return a JSON object with a "tasks" array containing task objects. Each task must have: name, description, estimated_hours (integer), priority, category, tags (array).'
      }, {
        role: 'user',
        content: prompt
      }],
      temperature: 0.7,
      max_tokens: 2000,
      response_format: { type: 'json_object' }
    })
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('OpenAI API error:', response.status, errorText);
    return [];
  }

  const data = await response.json();
  const tasksText = data.choices[0].message.content;

  console.log('\nüîç RAW OPENAI RESPONSE:');
  console.log('‚îÅ'.repeat(80));
  console.log(tasksText);
  console.log('‚îÅ'.repeat(80));

  return extractTasksFromJSON(tasksText);
}

/**
 * Extract JSON array from AI response text
 */
function extractTasksFromJSON(text) {
  try {
    console.log('üîÑ Parsing AI response...');

    // First try to parse as direct JSON
    const parsed = JSON.parse(text);
    console.log('‚úÖ JSON parsed successfully. Type:', Array.isArray(parsed) ? 'array' : 'object');

    let tasksArray = [];

    // If it's an object with a tasks property, use that
    if (parsed.tasks && Array.isArray(parsed.tasks)) {
      console.log(`‚úÖ Found 'tasks' array with ${parsed.tasks.length} items`);
      tasksArray = parsed.tasks;
    }
    // If it's already an array, use it
    else if (Array.isArray(parsed)) {
      console.log(`‚úÖ Response is already an array with ${parsed.length} items`);
      tasksArray = parsed;
    }
    // Try to find any array property in the object
    else if (typeof parsed === 'object') {
      console.log('üîç Searching for array properties in object...');
      for (const [key, value] of Object.entries(parsed)) {
        if (Array.isArray(value)) {
          console.log(`‚úÖ Found array property '${key}' with ${value.length} items`);
          tasksArray = value;
          break;
        }
      }
    }

    if (tasksArray.length === 0) {
      console.error('‚ùå No task array found in response');
      console.log('Parsed object keys:', Object.keys(parsed));
      return [];
    }

    // Validate and normalize each task
    console.log(`üîç Validating ${tasksArray.length} tasks...`);
    const validTasks = tasksArray.map((task, index) => {
      console.log(`Task ${index + 1}:`, task);

      // Ensure required fields exist
      const normalizedTask = {
        name: task.name || task.title || task.task || `Unnamed Task ${index + 1}`,
        description: task.description || task.desc || '',
        estimated_hours: parseInt(task.estimated_hours || task.hours || task.duration || 4),
        priority: task.priority || 'Medium',
        category: task.category || task.type || 'Custom Development',
        tags: Array.isArray(task.tags) ? task.tags : (task.tags ? [task.tags] : ['Custom'])
      };

      console.log(`  ‚úÖ Normalized:`, normalizedTask);
      return normalizedTask;
    });

    console.log(`‚úÖ Successfully validated ${validTasks.length} tasks`);
    return validTasks;

  } catch (error) {
    console.error('‚ùå Error parsing AI response:', error);
    console.error('Raw text:', text);
    return [];
  }
}

/**
 * Build context object from questionnaire responses
 */
function buildContext(responses) {
  return {
    // Project basics
    industry: responses.industry || 'General',
    country: responses.country || '',
    language: responses.language || 'English',

    // Hour budgets
    clarity_hours: responses.clarity_hours || 40,
    implementation_hours: responses.implementation_hours || 100,
    adoption_hours: responses.adoption_hours || 20,

    // Clarity phase context
    current_systems: responses.current_systems || '',
    pain_points: responses.pain_points || '',
    core_processes: responses.core_processes || '',

    // Implementation context
    modules: responses.modules || [],
    data_migration: responses.data_migration || 'No',
    data_migration_scope: responses.data_migration_scope || '',
    integrations: responses.integrations || 'No',
    integration_list: responses.integration_list || '',
    customizations: responses.customizations || 'No',
    customization_scope: responses.customization_scope || '',
    multi_company: responses.multi_company || 'No',
    company_count: responses.company_count || 1,
    multi_warehouse: responses.multi_warehouse || 'No',
    warehouse_count: responses.warehouse_count || 1,

    // Adoption context
    user_count: responses.user_count || 0,
    user_breakdown: responses.user_breakdown || '',
    training_format: responses.training_format || 'Hybrid',
  };
}

/**
 * Build AI prompt based on phase and context
 */
function buildPrompt(context, phase, language) {
  const baseInstructions = `You are an expert Odoo implementation consultant at Arkode.

CRITICAL RULES:
- Return ONLY a valid JSON object with a "tasks" array - NO other text before or after
- Tasks must be in ${language} language
- Estimated hours must be whole numbers only (no decimals)
- Each task must have: name, description, estimated_hours, priority, category, tags (array)

Context:
Industry: ${context.industry}
Country: ${context.country}
Modules: ${context.modules.join(', ')}
`;

  if (phase === 'clarity') {
    return `${baseInstructions}
Current Systems: ${context.current_systems}
Pain Points: ${context.pain_points}
Core Processes: ${context.core_processes}

TASK: Generate 2-3 specific Clarity phase discovery tasks ONLY.

BUDGET CONSTRAINT: Total hours for ALL tasks must NOT exceed ${Math.round(context.clarity_hours * 0.3)} hours (30% of Clarity budget is for AI tasks, rest is template).

Focus on:
- Specific process mapping from current systems mentioned
- Workshops addressing the exact pain points listed
- Discovery sessions for the core processes described

DO NOT generate generic tasks. Use the specific systems, pain points, and processes mentioned above.

Return format:
{
  "tasks": [
    {
      "name": "Mapear proceso espec√≠fico desde [sistema actual]",
      "description": "Detailed description",
      "estimated_hours": 6,
      "priority": "High",
      "category": "Process Mapping",
      "tags": ["Clarity", "Discovery"]
    }
  ]
}`;
  }

  if (phase === 'implementation') {
    // Calculate available hours for AI tasks (custom dev portion)
    const customDevBudget = Math.round(context.implementation_hours * 0.5); // 50% for custom work

    return `${baseInstructions}
Data Migration Scope: ${context.data_migration_scope}
Integration Requirements: ${context.integration_list || 'None'}
Custom Development Required: ${context.customization_scope}
Multi-company: ${context.multi_company} ${context.multi_company === 'Yes' ? `(${context.company_count} companies)` : ''}
Multi-warehouse: ${context.multi_warehouse} ${context.multi_warehouse === 'Yes' ? `(${context.warehouse_count} warehouses)` : ''}

TASK: Generate 2-4 specific Implementation tasks for DATA MIGRATION and CUSTOM DEVELOPMENT only.

BUDGET CONSTRAINT: Total hours for ALL tasks must NOT exceed ${customDevBudget} hours.

IMPORTANT - Generate tasks ONLY for:
1. Data migration from systems mentioned (if scope provided)
2. Custom module development described in "Custom Development Required" section
3. Third-party integrations listed (if any)

DO NOT generate tasks for:
- Standard Odoo module configuration (CRM, Sales, etc.) - templates handle this
- Training or user adoption - that's the Adoption phase
- Generic setup tasks

Break down custom modules into logical sub-tasks (design, development, testing, integration).
Each task should be 15-40 hours maximum.

Return format:
{
  "tasks": [
    {
      "name": "Migraci√≥n de datos de [sistema espec√≠fico]",
      "description": "Detailed migration plan",
      "estimated_hours": 30,
      "priority": "High",
      "category": "Data Migration",
      "tags": ["Implementation", "Migration"]
    }
  ]
}`;
  }

  if (phase === 'adoption') {
    return `${baseInstructions}
User Count: ${context.user_count}
User Breakdown: ${context.user_breakdown}
Training Format: ${context.training_format}

TASK: Generate 2-4 specific Adoption phase tasks focused on TRAINING and CHANGE MANAGEMENT only.

BUDGET CONSTRAINT: Total hours for ALL tasks must NOT exceed ${Math.round(context.adoption_hours * 0.5)} hours (50% of Adoption budget).

CRITICAL - Generate tasks ONLY for:
1. Role-based training sessions for user groups mentioned
2. Change management workshops
3. Documentation creation
4. Go-live support planning

DO NOT generate tasks for:
- Building features or modules (that's Implementation phase!)
- Configuring integrations (that's Implementation phase!)
- Data migration (that's Implementation phase!)
- System development (that's Implementation phase!)

Focus on how to TRAIN users on the already-built system, NOT on building new features.

Example of CORRECT Adoption tasks:
- "Capacitaci√≥n para equipo de ventas en m√≥dulos CRM y Ventas" (8h)
- "Taller de gesti√≥n del cambio para l√≠deres" (4h)
- "Documentaci√≥n de procesos y gu√≠as de usuario" (6h)

Example of WRONG Adoption tasks (these are Implementation!):
- "Integraci√≥n de inventario en tiempo real" ‚ùå
- "Sistema de geolocalizaci√≥n" ‚ùå
- "Dashboard de rentabilidad" ‚ùå

Return format:
{
  "tasks": [
    {
      "name": "Capacitaci√≥n por roles para [grupo de usuarios]",
      "description": "Training session details",
      "estimated_hours": 8,
      "priority": "High",
      "category": "Training",
      "tags": ["Adoption", "Training"]
    }
  ]
}`;
  }

  return baseInstructions + '\nReturn only the JSON object with tasks array.';
}

/**
 * Check if AI customization is available
 * @returns {Object} { available: boolean, provider: 'claude'|'openai'|null }
 */
export function getAICustomizationStatus() {
  const { provider } = detectProvider();
  return {
    available: !!provider,
    provider: provider
  };
}
